--- a/arch/x86/entry/syscalls/syscall_32.tbl	2016-10-07 21:03:33.000000000 +0800
+++ b/arch/x86/entry/syscalls/syscall_32.tbl	2016-12-15 09:15:39.623709084 +0800
@@ -386,3 +386,6 @@
 377	i386	copy_file_range		sys_copy_file_range
 378	i386	preadv2			sys_preadv2			compat_sys_preadv2
 379	i386	pwritev2		sys_pwritev2			compat_sys_pwritev2
+
+400 i386    num_context_switches    sys_num_context_switches
+
--- a/arch/x86/include/asm/syscalls.h	2016-10-07 21:03:33.000000000 +0800
+++ b/arch/x86/include/asm/syscalls.h	2016-12-15 09:14:41.252841021 +0800
@@ -52,4 +52,7 @@
 			 unsigned long, unsigned long, unsigned long);
 
 #endif /* CONFIG_X86_32 */
+
+asmlinkage long sys_num_context_switches(unsigned long num);
+
 #endif /* _ASM_X86_SYSCALLS_H */
--- a/include/linux/sched.h	2016-10-07 21:03:33.000000000 +0800
+++ b/include/linux/sched.h	2016-12-14 17:00:27.836988817 +0800
@@ -1458,6 +1458,7 @@
 };
 
 struct task_struct {
+    int cs_num;
 	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
 	void *stack;
 	atomic_t usage;
--- a/kernel/fork.c	2016-10-07 21:03:33.000000000 +0800
+++ b/kernel/fork.c	2016-12-14 16:56:38.580441970 +0800
@@ -1672,6 +1672,7 @@
 	trace_task_newtask(p, clone_flags);
 	uprobe_copy_process(p, clone_flags);
 
+    p->cs_num = 0;
 	return p;
 
 bad_fork_cancel_cgroup:
--- a/kernel/sched/core.c	2016-10-07 21:03:33.000000000 +0800
+++ b/kernel/sched/core.c	2016-12-15 09:38:34.845401260 +0800
@@ -2886,6 +2886,8 @@
 	switch_to(prev, next, prev);
 	barrier();
 
+    prev->cs_num++;
+
 	return finish_task_switch(prev);
 }
 
--- a/kernel/sched/Makefile	2016-10-07 21:03:33.000000000 +0800
+++ b/kernel/sched/Makefile	2016-12-15 09:19:01.490046663 +0800
@@ -25,3 +25,5 @@
 obj-$(CONFIG_CGROUP_CPUACCT) += cpuacct.o
 obj-$(CONFIG_CPU_FREQ) += cpufreq.o
 obj-$(CONFIG_CPU_FREQ_GOV_SCHEDUTIL) += cpufreq_schedutil.o
+
+obj-y += proj2.o
--- a/kernel/sched/proj2.c	1970-01-01 08:00:00.000000000 +0800
+++ b/kernel/sched/proj2.c	2016-12-15 10:22:16.406639463 +0800
@@ -0,0 +1,18 @@
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+#include "sched.h"
+
+SYSCALL_DEFINE1(num_context_switches, unsigned long*, num)
+{
+    int cpu;
+    struct rq *rq;
+    struct task_struct *curr;
+
+    cpu = smp_processor_id();
+    rq = cpu_rq(cpu);
+    curr = rq->curr;
+
+    *num = current->cs_num;
+    return 0;
+}
+
