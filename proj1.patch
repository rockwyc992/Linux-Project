--- a/arch/x86/entry/syscalls/syscall_32.tbl      2016-10-07 21:03:33.000000000 +0800
+++ b/arch/x86/entry/syscalls/syscall_32.tbl	    2016-10-31 14:34:11.412737172 +0800
@@ -386,3 +386,5 @@
 377	i386	copy_file_range		sys_copy_file_range
 378	i386	preadv2			sys_preadv2			compat_sys_preadv2
 379	i386	pwritev2		sys_pwritev2			compat_sys_pwritev2
+
+400	i386	address_space_survey    sys_address_space_survey
--- a/include/linux/syscalls.h	    2016-10-07 21:03:33.000000000 +0800
+++ b/include/linux/syscalls.h	    2016-10-31 14:03:31.549388463 +0800
@@ -898,4 +898,6 @@
 
 asmlinkage long sys_mlock2(unsigned long start, size_t len, int flags);
 
+asmlinkage long sys_address_space_survey(int first, int last, int *result);
+
 #endif
--- a/kernel/Makefile   	2016-10-07 21:03:33.000000000 +0800
+++ b/kernel/Makefile	    2016-10-31 13:56:49.132718435 +0800
@@ -11,6 +11,8 @@
 	    notifier.o ksysfs.o cred.o reboot.o \
 	    async.o range.o smpboot.o
 
+obj-y += proj1.o
+
 obj-$(CONFIG_MULTIUSER) += groups.o
 
 ifdef CONFIG_FUNCTION_TRACER
--- a/kernel/proj1.c	1970-01-01 08:00:00.000000000 +0800
+++ b/kernel/proj1.c	2016-10-31 15:29:58.122765139 +0800
@@ -0,0 +1,158 @@
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+#include <asm/mmu_context.h>
+#include <linux/bootmem.h>
+
+/*
+static inline unsigned long read_cr3(void)
+{
+    unsigned long val;
+    asm volatile("mov %%cr3,%0\n\t" : "=r" (val), "=m" (__force_order));
+    return val;
+}
+*/
+
+static int bad_address(void *p)
+{
+        unsigned long dummy;
+
+            return probe_kernel_address((unsigned long *)p, dummy);
+}
+
+#ifdef CONFIG_X86_32
+static bool low_pfn(unsigned long pfn) 
+{
+    return pfn < max_low_pfn;
+}
+
+static void dump_pagetable(unsigned long address)
+{
+    pgd_t *base = __va(read_cr3());
+    pgd_t *pgd = base + pgd_index(address);
+    pmd_t *pmd;
+    pte_t *pte;
+
+#ifdef CONFIG_X86_PAE
+    printk("*pdpt = %016Lx ", pgd_val(*pgd));
+    if (!low_pfn(pgd_val(*pgd) >> PAGE_SHIFT) || !pgd_present(*pgd))
+        goto out; 
+#endif
+    pmd = pmd_offset(pud_offset(pgd, address), address);
+    printk(KERN_CONT "*pde = %0*Lx ", sizeof(*pmd) * 2, (u64)pmd_val(*pmd));
+
+    /*   
+     * We must not directly access the pte in the highpte
+     * case if the page table is located in highmem.
+     * And let's rather not kmap-atomic the pte, just in case
+     * it's allocated already:
+     */
+    if (!low_pfn(pmd_pfn(*pmd)) || !pmd_present(*pmd) || pmd_large(*pmd))
+        goto out; 
+
+    pte = pte_offset_kernel(pmd, address);
+    printk("*pte = %0*Lx ", sizeof(*pte) * 2, (u64)pte_val(*pte));
+out:
+    printk("\n");
+}
+#else /* CONFIG_X86_64: */
+static void dump_pagetable(unsigned long address)
+{
+	pgd_t *base = __va(read_cr3() & PHYSICAL_PAGE_MASK);
+	pgd_t *pgd = base + pgd_index(address);
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
+
+	if (bad_address(pgd))
+		goto bad;
+
+	printk("PGD %lx ", pgd_val(*pgd));
+
+	if (!pgd_present(*pgd))
+		goto out;
+
+	pud = pud_offset(pgd, address);
+	if (bad_address(pud))
+		goto bad;
+
+	printk("PUD %lx ", pud_val(*pud));
+	if (!pud_present(*pud) || pud_large(*pud))
+		goto out;
+
+	pmd = pmd_offset(pud, address);
+	if (bad_address(pmd))
+		goto bad;
+
+	printk("PMD %lx ", pmd_val(*pmd));
+	if (!pmd_present(*pmd) || pmd_large(*pmd))
+		goto out;
+
+	pte = pte_offset_kernel(pmd, address);
+	if (bad_address(pte))
+		goto bad;
+
+	printk("PTE %lx", pte_val(*pte));
+out:
+	printk("\n");
+	return;
+bad:
+	printk("BAD\n");
+}
+#endif
+
+SYSCALL_DEFINE3(address_space_survey, int, first, int, last, int*, result)
+{
+    /*printk(KERN_INFO "cr0 = %X\n", cr0);
+    printk(KERN_INFO "cr2 = %X\n", cr2);
+    printk(KERN_INFO "cr3 = %X\n", cr3);
+
+    printk("Hello, %d + %d = %d\n", first, last, first + last);*/
+    unsigned long address = read_cr2();
+	pgd_t *base = __va(read_cr3() & PHYSICAL_PAGE_MASK);
+    pgd_t *pgd;
+    unsigned long i;
+    int j;
+    pgdval_t val;
+
+    dump_pagetable(address);
+    address = result;
+    dump_pagetable(address);
+
+    if (first > last) {
+        int tmp = first;
+        first = last;
+        last = tmp;
+    }
+    if (first < 0) {
+        first = 0;
+    }
+    if (last >= 1024) {
+        last = 1023;
+    }
+
+    /*for (i = first, j = 0; i <= last; i++, j++) {
+        if (j%32 == 0) {
+            printk("%u:\n", i);
+        }
+	    pgd = base + i;
+        printk("%8lx ", pgd_val(*pgd));
+        if (j%8 == 7) {
+            printk("\n");
+        }
+    }*/
+
+    for (i = first, j = 0; i <= last; i++) {
+	    pgd = base + i;
+        val = pgd_val(*pgd);
+        if (val) {
+            printk("%4u: %8lx ", i, val);
+            j++;
+            if (j%8 == 0) {
+                printk("\n");
+            }
+        }
+    }
+    printk("\n");
+
+    return 0;
+}
